# -*- coding: utf-8 -*-
"""Lab03_Q3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TtCadIpQwE_6r_6PLn_7vmGiaipZ0U3z
"""

#Author: Ben Campbell
#Purpose: To explore various methods of numerical differentiation.

#import packages
import numpy as np
import matplotlib.pyplot as plt
import sympy as sp
sp.init_printing()
import pandas as pd

#Define the function that we will differentiate

def f(x):
  return np.exp(-x**2)

# create several values of h differing by an order of magnetude each step
h = np.array([(1e-16)*10**i for i in range(17)])
#print(h)

# implement forward finite difference
def ffd(function,x,h):
  #need function to be able to handle an array, thus the input funciton must handle arrays
  return np.divide((function(np.add(h,x))-function(x)),h)

# implement central finite difference
def cfd(function,x,h):
  return np.divide((function(np.add(h,x))-function(np.add(-h,x))),2*h)

# Question 3a: Compute ffd for each h in the array
forward = ffd(f,0.5,h)
print(forward)

# Question 3b: Compute the error of each value in the forward array
def f_prime(x):
  return -2*x*np.exp(-x**2)
def f_dopple_prime(x):
  return 4*x**2*f(x) - 2*f(x)
forward_error_estimate = np.abs(h/2 * f_dopple_prime(0.5)) #ignoring higher order terms
#print("estimated error: ", forward_error_estimate)

#find analytical calue of the derivative:
x = sp.var('x')
analytical_value = sp.diff(sp.exp(-x**2),x).subs(x,0.5)

# find exact error
exact_error = np.abs(analytical_value - forward)
#print("exact error:", exact_error)

# Organize the data into a table
forward_table = pd.DataFrame({'h':h,'forward derivative':forward,'exact error':exact_error, 'error estimate': forward_error_estimate},columns=['h','forward derivative','exact error', "error estimate"])
print(forward_table)

from logging import error
# Question 3c

#plot the exact error
plt.plot(forward_table['h'],forward_table['exact error'],marker='.',ls=':', label="exact errors")
plt.loglog()
plt.xlabel('h')
plt.ylabel('error')
plt.title('Exact Error in Forward Finite\nDifference Scheme for Various Step Sizes')
plt.grid()
#plot the error according to Newman 5.91
#get the machine error:
C = np.finfo(np.float64).eps
#implement 5.91
h_fine = np.array([1e-16 * 2.**i for i in range(53)]) #higher resolution
theoretical_error = np.divide(2*C*np.abs(f(0.5)),h_fine) + 0.5*np.abs(f_dopple_prime(0.5))*h_fine
plt.plot(h_fine,theoretical_error,marker='none',ls='-.', label='theoretical error depedance on h')
plt.legend()
plt.show()

# Question 3d

central = cfd(f,0.5,h)

# find exact error
c_exact_error = np.abs(analytical_value - central)
#print("exact error:", exact_error)

# Organize the data into a table
central_table = pd.DataFrame({'h':h,'central derivative':central,'exact error':c_exact_error})
print(forward_table)

#plot the exact error
plt.plot(forward_table['h'],forward_table['exact error'],marker='.',ls=':', label="exact forward errors")
plt.plot(forward_table['h'],central_table['exact error'],marker='.',ls=':', label="exact central errors")
plt.loglog()
plt.xlabel('h')
plt.ylabel('error')
plt.title('Exact Error in Forward and Central Finite\nDifference Schemes for Various Step Sizes')
plt.grid()
#plot the error according to Newman 5.91
plt.plot(h_fine,theoretical_error,marker='none',ls='-.', label='forward theoretical error depedance on h')
#implement eq 5.99:
#third derivative of f at 0.5
d_3_f = sp.diff(sp.diff(sp.diff(sp.exp(-x**2),x),x),x).subs(x,0.5)
#plot
central_error_estimate = 2*C*np.abs(f(0.5))/h_fine + h_fine**2 /24 *np.abs(d_3_f)
plt.plot(h_fine, central_error_estimate, ls='-.', label="central theoretical error depedance on h")
plt.legend()
plt.show()

