# -*- coding: utf-8 -*-
"""Lab06_Q1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p3Lwqz90KmkB6kGKCm7FtIDdteKdRYuJ

Author: Ben Campbell


Purpose: Here we investigate some analytical results of the stick-slip friction model. We use RK4 methods to nummerically appromimate the solution curves of our model.
"""

import numpy as np
import matplotlib.pyplot as plt

# part A
# subpart i - plot the total absolute friction force

def F_f(alpha, dot_x: np.ndarray): # returns the fluid friction when given the friction constant and an array of velocities.
  return -alpha*dot_x

def F_s(beta, v_f, dot_x: np.ndarray): # returns an approximate static friction given the parameters beta and v_f
  return -beta*np.exp(-np.abs(dot_x) / v_f)

def friction_force(dot_x: np.ndarray,alpha, beta, v_f):
  return F_f(alpha, dot_x) + F_s(beta, v_f, dot_x)

# plot the total absolute friction force

#create a velocity array:
dot_xs = np.linspace(1e-10,10,1000)

plt.plot(dot_xs, np.abs(friction_force(dot_xs, 1, 2, 0.1)))
plt.title('Magnetude of total friction as a function of velocity')
plt.xlabel(r'velocity $\left(\frac{m}{s}\right)$')
plt.ylabel('Magnetude of force ($N$)')
plt.show()

# part b

#define parameters
gamma = 0
tau = 1
v_f = 1
v_p = 0
omega = 1

#define the ODE

def equation_of_motion(t, x, dot_x):

  dot_v = -omega**2 * (x - v_p * t) - gamma * np.exp(-np.abs(dot_x)/v_f) - dot_x/tau

  return [dot_x,dot_v] # retun a list

def frictionless_equation_of_motion(t, x, dot_x):
  return [dot_x, -omega**2 * (x - v_p * t)]

# write a function to do 4th order RK integration

def rk4(f, initial_conditions, t_final, dt): #integrates with RK4. initial conditions must be given with time first - ODE must take time as first argument
  # f should output an n-list of floats. Each entry of this list gives the derivative of the ith 1st order ODE.
  tpoints = np.arange(initial_conditions[0],t_final,dt)
  # we want this to generalize to a system of n ODEs
  n = len(initial_conditions) - 1 # subtract one because we don't want to count t_0
  xpoints = { "x_%i"%i : [initial_conditions[i+1]] for i in range(n)} # initialize the list of coordinates with the initial conditions
  # use a dictionary so that it is variable length
  for t_i in range(len(tpoints)-1):
    for i in range(n):
      current_conditions = [ xpoints["x_%i"%j][t_i] for j in range(n) ]   #take the last of each coordinate; use t_i index so that on loop t_i we only use the conditions from t_i-1 not a mix (index of -1 would cause a mix).
      k1 = dt*f(tpoints[t_i],*current_conditions)[i] # since f may be a function of arbitray many coordinates we unpack the list
      k2 = dt*f(tpoints[t_i]+0.5*dt,*[current_conditions[j] + 0.5*k1 for j in range(n)])[i]
      k3 = dt*f(tpoints[t_i]+0.5*dt,*[current_conditions[j] + 0.5*k2 for j in range(n)])[i]
      k4 = dt*f(tpoints[t_i]+dt,*[current_conditions[j] + k3 for j in range(n)])[i]
      xpoints["x_%i"%i].append(current_conditions[i])
      xpoints["x_%i"%i][-1] += (k1+2*k2+2*k3+k4)/6 # i have reservation about the efficiency of all this list generation and unpacking but I can't think of a better way to do this in complete generality
  return tpoints, [xpoints["x_%i"%i] for i in range(n)] # times and list of lists

#choose an appropraite dt based on energy loss
# we'll say dt is sufficient when the deviation between the final and initial energy is less than 1% of the initial energy
def Energy(t,x,dot_x):
  return dot_x**2 + omega**2*(x-v_p*t)**2

dt = 0.01
loss = 1
while loss >= 0.01: # iterate untill the energy loss is less than 1%
  t, l = rk4(frictionless_equation_of_motion, [0,1,0], 10, dt)
  loss = np.abs(( Energy(t[-1],l[0][-1],l[1][-1])-Energy(t[0],l[0][0],l[1][0])) / Energy(t[0],l[0][0],l[1][0]))
  print(loss)
  dt /= 10.

print("dt to conserve energy at {0:.4f} :".format(loss), dt)

# test the function with no friction force

t, l = rk4(frictionless_equation_of_motion, [0,1,0], 10, dt)
fig, (ax1, ax2, axE) = plt.subplots(3,1,figsize=(15,8),sharex=True)
ax1.plot(t, l[0],label='rk4 trajectory')
ax2.plot(t, np.abs(l[0]-np.cos(t))/np.abs(np.cos(t)), label='rk4 trajectory relative error from theoretical solution', color='orange')
axE.plot(t,Energy(t,np.array(l[0]),np.array(l[1])), label="Energy of the rk4 trajectory", color = 'r')
fig.suptitle(r"Trajectory in the no friction case and $\omega_0^2=1~Hz^2$, $x_0=1~m$, $v_0 = 0~\frac{m}{s}$")
plt.xlabel("Time (s)")
ax1.set_ylabel("Position (m)")
ax2.set_ylabel("deviation from theoretical solution")
axE.set_ylabel("Energy (J)")
fig.tight_layout()
fig.legend()
plt.show()

# part iii
#define parameters
gamma = 0.5
tau = 1
v_f = 0.1
v_p = 0.1
omega = 1

#define the ODE

def equation_of_motion(t, x, dot_x): # must redefine because parameters changed

  dot_v = -omega**2 * (x - v_p * t) - gamma * np.exp(-np.abs(dot_x)/v_f) - dot_x/tau

  return [dot_x,dot_v] # return a list
def Energy(t,x,dot_x):
  return dot_x**2 + omega**2*(x-v_p*t)**2

x_0 = (-gamma*np.exp(-v_p/v_f) - v_p/tau) / omega**2 # constant velocity initial condition

t, l = rk4(equation_of_motion, [0,x_0,v_p], 10, dt)

fig, (ax1, ax_v, ax_dv, axE) = plt.subplots(4,1,figsize=(15,16),sharex=True)
ax1.plot(t, l[0],label='rk4 trajectory')
#ax2.plot(t[1::], (np.abs(np.array(l[0])-(v_p*t))/(v_p*t))[1::], label='rk4 trajectory relative error from theoretical solution', color='orange')
#ax2.set_ylim((0,2))
ax_dv.plot(t, (np.abs(np.array(l[1])-(v_p))/(v_p)), label='rk4 velocity relative error from theoretical solution', color='blue')
ax_dv.set_ylabel("deviation from theoretical solution")
axE.plot(t,Energy(t,np.array(l[0]),np.array(l[1])), label="Energy of the rk4 trajectory", color = 'r')
fig.suptitle(r"Trajectory in the friction case and $\omega_0^2=1~Hz^2$, $v_p = 0.1~\frac{m}{s}$, $v_f = 0.1~\frac{m}{s}$, $\tau = 1~s$, $\gamma = 0.5~\frac{m}{s^2}$, $x_0\approx -0.2839~m$, $v_0 = 0.1~\frac{m}{s}$")
ax_v.plot(t, l[1],label='rk4 velocity', color='purple')
ax_v.set_ylabel("Velocity (m/s)")
plt.xlabel("Time (s)")
ax1.set_ylabel("Position (m)")
#ax2.set_ylabel("deviation from theoretical solution")
axE.set_ylabel("Energy (J)")
fig.tight_layout()
fig.legend(bbox_to_anchor = (0.955,0.9))
plt.show()

# now we verify the theoretical solution to part (a)v
# we now have the additional conditions that tau = 1 + v_p/v_f and v_f = gamma*tau*exp(-v_p/v_f)
# then given that gamma = 0.5, tau = 2 we are prescribed v_p/v_f = 1 by the first constraint. We then have v_f = gamma*tau/e = 1/e so v_p = 1/e.

#define parameters
gamma = 0.5
tau = 2
v_f = np.exp(-1)
v_p = np.exp(-1)
omega = 1

#define the ODE

def equation_of_motion(t, x, dot_x): # must redefine because parameters changed

  dot_v = -omega**2 * (x - v_p * t) - gamma * np.exp(-np.abs(dot_x)/v_f) - dot_x/tau

  return [dot_x,dot_v] # return a list

def Energy(t,x,dot_x):
  return dot_x**2 + omega**2*(x-v_p*t)**2

t, l = rk4(equation_of_motion, [0,x_0,0], 10, dt) #x_0 is unchanged

fig, (ax1, ax_decomp, axE) = plt.subplots(3,1,figsize=(15,10),sharex=True)
ax1.plot(t, l[0],label='rk4 trajectory')
axE.plot(t,Energy(t,np.array(l[0]),np.array(l[1])), label="Energy of the rk4 trajectory", color = 'r')
fig.suptitle(r"Trajectory in the friction case and $\omega_0^2=1~Hz^2$, $v_p = \frac{1}{e}~\frac{m}{s}$, $v_f = \frac{1}{e}~\frac{m}{s}$, $\tau = 2~s$, $\gamma = 0.5~\frac{m}{s^2}$, $x_0\approx -0.2839~m$, $v_0 = 0~\frac{m}{s}$")
plt.xlabel("Time (s)")
ax1.set_ylabel("Position (m)")
axE.set_ylabel("Energy (J)")

u = np.array(l[0]) - v_p*t - x_0
ax_decomp.plot(t, u, color = 'purple', label = r"$x(t) = v_p\cdot t-x_0$")
ax_decomp.set_ylabel("$u(t)$: deviation from\n$x(t)=v_p\cdot t$ (m)")

theoretical_u = -v_p/omega * np.cos(omega*t - np.pi/2)
ax_decomp.plot(t,theoretical_u, color = 'cyan', label = "theoretical u(t)")
'''ax_u_err.plot(t, np.abs(u - theoretical_u)/theoretical_u)
ax_u_err.set_ylabel("relative error of $u(t)$ from\ntheoretical solution for $u(t)$")'''

fig.tight_layout()
fig.legend(loc="upper right")
plt.show()



