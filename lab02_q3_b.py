# -*- coding: utf-8 -*-
"""Lab02_Q3_b.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G-JSnn4igZGz7AIS06vXeERlFvPEB3Xz
"""

#Author: Ben Campbell
#Purpose: To draw voltage contours
import numpy as np
import matplotlib.pyplot as plt
from scipy import constants as c

#Start by redefineing the functions from the previous part

l = 1./1000. #m (1. mm)
Q = 1e-13 #C
eps = c.epsilon_0

def integrand(u,r,z):
    return Q*np.exp(-(np.tan(u))**2)/ ( 4*c.pi * eps * (np.cos(u))**2 * np.sqrt((z-l*np.tan(u))**2 + r**2) )

def integrate_Simpson(function, start, end, num_intervals):
  if type(num_intervals) != int:
    num_intervals = int(num_intervals)

  interval_width = (end - start) / num_intervals

  sum_even = 0.
  sum_odd = 0.

  if num_intervals % 2 != 0:
    effective_num_intervals = num_intervals - 1
  else:
    effective_num_intervals = num_intervals

  for i in range(1, effective_num_intervals, 2):
    sum_even += 2.*function(start + interval_width * (i+1))
    sum_odd += 4.*function(start + interval_width * i)

  if num_intervals % 2 != 0:
    #Do a trapezoidal area on the last segment
    last_area = interval_width*( function(end-interval_width) + function(end) )/2
    return interval_width/3 * (function(start) + function(end) + sum_even + sum_odd) + last_area
  else:
    return interval_width/3 * (function(start) + function(end) + sum_even + sum_odd)

def voltage(r,z,num_intervals):
  num_intervals = int(num_intervals)
  if type(r) != list and type(r) != np.ndarray:
    r = np.array([r])
  integrands = {"integrand_{0}".format(i): (lambda u, i=i: integrand(u, r[i], z)) for i in range(len(r))} # must use i=i to avoid late binding
  sol = np.array([integrate_Simpson(integrands["integrand_%i"%i], -c.pi/2., c.pi/2., num_intervals) for i in range(len(r))])
  return sol

# New code starts here
"""
Pseudocode:

create a list of z and r values in between 0.25 and 5 mm (convert to meters)

find voltage at each point in (z,r) space - this gives us a matix of data

put matrix into imshow from pylab package

choose appropriate color scheme and labels.

"""

from matplotlib.pylab import imshow #Newman's book uses this for interference patterns, but it should work here too.
import matplotlib.pylab as pyb

n = 1000 #numper of values to sample from z and r
N = 50 # number of partitions in the integral estimation

# generate the lattice in (r,z) space
radii = np.linspace(0.25/1e3, 5/1e3, n)
z_values = np.linspace(-5/1e3, 5/1e3, n)

# get the potential matrix
Potential_matrix = np.zeros((n,n))
for i in range(n): #rows
  for j in range(n): #columns
    Potential_matrix[i,j] = voltage(radii[i],z_values[j],N)[0] #voltage outputs an array, so we extract the single element

print(Potential_matrix)

imshow(Potential_matrix)
plt.yticks([i for i in range(0,n,100)],["{0:.2f}".format(radii[i]*1000.) for i in range(0,n,100)])
plt.xticks([i for i in range(0,n,200)],["{0:.2f}".format(z_values[i]*1000.) for i in range(0,n,200)],rotation='vertical')
plt.xlabel("z (mm)")
plt.ylabel("r (mm)")
plt.colorbar(label = "Electric Potential (V)")
plt.title("Electric potential field")
pyb.jet()
plt.show()

