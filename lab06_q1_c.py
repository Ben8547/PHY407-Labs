# -*- coding: utf-8 -*-
"""Lab06_Q1_c.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aP5o8W9ztZDuKDh-XhO2EmyQ6xQux-IK

Author: Ben Campbell


Purpose: Here we investigate some analytical results of the stick-slip friction model. We use RK4 methods to nummerically approximate the solution curves of our model.
"""

import numpy as np
import matplotlib.pyplot as plt

# write a function to do 4th order RK integration

def rk4(f, initial_conditions, t_final, dt): #integrates with RK4. initial conditions must be given with time first - ODE must take time as first argument
  # f should output an n-list of floats. Each entry of this list gives the derivative of the ith 1st order ODE.
  tpoints = np.arange(initial_conditions[0],t_final,dt)
  # we want this to generalize to a system of n ODEs
  n = len(initial_conditions) - 1 # subtract one because we don't want to count t_0
  xpoints = { "x_%i"%i : [initial_conditions[i+1]] for i in range(n)} # initialize the list of coordinates with the initial conditions
  # use a dictionary so that it is variable length
  for t_i in range(len(tpoints)-1):
    for i in range(n):
      current_conditions = [ xpoints["x_%i"%j][t_i] for j in range(n) ]   #take the last of each coordinate; use t_i index so that on loop t_i we only use the conditions from t_i-1 not a mix (index of -1 would cause a mix).
      k1 = dt*f(tpoints[t_i],*current_conditions)[i] # since f may be a function of arbitray many coordinates we unpack the list
      k2 = dt*f(tpoints[t_i]+0.5*dt,*[current_conditions[j] + 0.5*k1 for j in range(n)])[i]
      k3 = dt*f(tpoints[t_i]+0.5*dt,*[current_conditions[j] + 0.5*k2 for j in range(n)])[i]
      k4 = dt*f(tpoints[t_i]+dt,*[current_conditions[j] + k3 for j in range(n)])[i]
      xpoints["x_%i"%i].append(current_conditions[i])
      xpoints["x_%i"%i][-1] += (k1+2*k2+2*k3+k4)/6 # i have reservation about the efficiency of all this list generation and unpacking but I can't think of a better way to do this in complete generality
  return tpoints, [xpoints["x_%i"%i] for i in range(n)] # times and list of lists

#define parameters
gamma = 0.5
tau = 2
v_f = np.exp(-1)
omega = 1

#define the ODE

def equation_of_motion(t, x, dot_x, v_p): # must redefine because parameters changed

  dot_v = -omega**2 * (x - v_p * t) - gamma * np.exp(-np.abs(dot_x)/v_f) - dot_x/tau

  return [dot_x,dot_v] # return a list

v_p = np.linspace(0.1*np.log(gamma*tau/v_f),1.5*np.log(gamma*tau/v_f),5) # generate an array of v_p
n=len(v_p)
#print(v_p)

fig, ax = plt.subplots(n,1, sharex=True)
for i in range(n):
  eom = lambda t, x, dxdt : equation_of_motion(t,x,dxdt,v_p[i])
  t, l = rk4(eom,[0,0,0],10,0.001)
  ax[i].plot(t,l[0],label = "$v_p =${0:.3f}".format(v_p[i]), color = (1-i/n,(i/n)**2,np.exp(i/n)-np.e*i/n))
  ax[i].set_ylabel('position (m)')


fig.suptitle("Trajectories of the System for various values of the driving velocity")
fig.legend()
ax[-1].set_xlabel('time (s)')
#fig.show()
plt.show()

