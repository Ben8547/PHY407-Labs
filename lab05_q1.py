# -*- coding: utf-8 -*-
"""Lab05_Q1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WR2Tnbj90Ie01bMDHpMdckG1mVqXV1sa

Author: Ben Campbell

PART: A

Purpose: Implement a DFT function and to find the DFT coeficients for various periodic functions.
"""

#!pip install warp-lang # TA should run this cell if warp is not already installed

import numpy as np
import matplotlib.pyplot as plt
import warp as wp
wp.init()

@wp.kernel # define the kernel function to compute the DFT coefficients; this allows us to compute each coeficient at the same time
def dft_coeff(y:wp.array(dtype=wp.float32),c:wp.array(dtype=wp.float32),N:int): # feed in an empty coefficient warp vector c to be filled and the samples y[n] and length of y as N
    k = wp.tid() # get the thread id
    k_prime = float(k) # cast k to float because warp cannot handle mixed types
    N_prime = float(N) # cast N to float because warp cannot handle mixed types

    #warp cannot handle complex math so we compute the real and imaginary parts separately
    # for reference: coeff = np.sum([y[n]*exp(-2j*np.pi*k*n/N) for n in range(N)])
    coeff_real = float(0.0) # initialize coeficients with float so that warp knows that they are dynamic variables and may be updated in the loop
    coeff_imag = float(0.0)
    for n in range(N):
        n_prime = float(n) # cast n to float because warp cannot handle mixed types
        angle = -2.0 * wp.pi * k_prime * n_prime / N_prime
        coeff_real += y[n] * wp.cos(angle)
        coeff_imag += y[n] * wp.sin(angle)

    c[2*k] = coeff_real # store the real part in the even indices
    c[2*k+1] = coeff_imag # store the imaginary part in the odd indices


def q_dft(y): # compute DFT of y[n] (real only) - use warp to compute the coefficients simultaneously for all k - should be faster; y must have an even number of samples
    if type(y) == np.ndarray:
        y = wp.from_numpy(y,dtype=wp.float32) # convert to warp array if input is a numpy array

    N = len(y)
    c = wp.zeros(2*(N//2+1),wp.float32) # initialize the coefficient vector; need twice the length to store real and imaginary parts if we intend to use warp

    if len(y) % 2 != 0:
        raise ValueError("Input array must have an even number of samples")

    wp.launch(kernel=dft_coeff,dim=N//2+1,inputs=[y,c,N]) # launch the kernel with N//2+1 threads
    c = c.numpy() # convert the warp vector back to a numpy array
    c = np.array([c[2*i]+1j*c[2*i+1] for i in range(N//2+1)],dtype=np.complex128) # Merge the real and imaginary parts back into complex numbers
    return c # only return half the coefficients due to complex conjugate symmetry

#Square wave
from time import time
N=1000
h = 1 #height of wave

y_square = np.array([1 if i < 500 else -1 for i in range(N)])
square_time = time()
c = q_dft(y_square)
#c = np.fft.rfft(y_square) # test
square_time = time() - square_time
print("Time to compute coeficients of the square wave", square_time)

fig , (ax1,ax2) = plt.subplots(2,1, sharex=False, figsize=(6,6))
ax2.bar([i for i in range(501)],abs(c)/N)
ax2.set_xlabel("Coefiecient index")
ax1.set_ylabel("Coeficient Amplitude")
ax2.set_ylabel("Coeficient Amplitude")
fig.suptitle("DFT coeficients of square wave")
ax1.set_title("Square wave")
ax1.plot(y_square)
ax2.set_title('Fourier Coeficients')
ax2.set_xlim(0,100)
plt.show()

#Sawtooth wave
saw_time = time()
y_saw = np.array([i for i in range(N)])
saw_time = time() - saw_time
c = q_dft(y_saw)
print("Time to compute coeficients of the sawtooth wave", saw_time)
#print(c)
fig , (ax1,ax2) = plt.subplots(2,1, sharex=False, figsize=(6,6))
ax2.bar([i for i in range(501)],abs(c)/N)
ax2.set_xlabel("Coefiecient index")
ax1.set_ylabel("Coeficient Amplitude")
ax2.set_ylabel("Coeficient Amplitude")
fig.suptitle("DFT coeficients of a sawtooth wave")
ax1.set_title("Sawtooth wave")
ax1.plot(y_saw)
ax2.set_title('Fourier Coeficients')
ax2.set_xlim(-1,100)
plt.show()

# @title
#modulated sine wave
y_mod = np.array([np.sin(np.pi*i/N) * np.sin(20.*np.pi*i/N) for i in range(N)])
mod_sine_time = time()
c = q_dft(y_mod)
mod_sine_time = time() - mod_sine_time
print("Time to compute coeficients of mod. sine wave with custom functions", mod_sine_time)
#print(c)
#plt.bar([i for i in range(501)],abs(c)/N)
#plt.xlim(0,50)
#plt.xlabel("Coefiecient index")
#plt.title("DFT coeficients of modulated sine wave")
#plt.ylabel("Coeficient Amplitude")
#plt.show()

fig , (ax1,ax2) = plt.subplots(2,1, sharex=False, figsize=(6,6))
ax2.bar([i for i in range(501)],abs(c)/N)
ax2.set_xlabel("Coefiecient index")
ax1.set_ylabel("Coeficient Amplitude")
ax2.set_ylabel("Coeficient Amplitude")
fig.suptitle("DFT coeficients of a modulated sine wave")
ax1.set_title("modulated sine wave")
ax1.plot([i/N for i in range(N)],y_mod)
ax2.set_title('Fourier Coeficients')
ax2.set_xlim(0,50)
plt.show()


#Compare against numpy FFT
numpy_fft_time = time()
c_np = np.fft.rfft(y_mod)
numpy_fft_time = time() - numpy_fft_time
print("Time to compute coeficients of mod. sine wave with numpy", numpy_fft_time)
plt.bar([i for i in range(501)],abs(c_np)/N)
plt.xlim(0,50)
plt.xlabel("Coefiecient index")
plt.ylabel("Coeficient Amplitude")
plt.title("DFT coeficients of modulated sine wave\ncomputed with numpy")
plt.show()

"""Author: Ben Campbell

PART: B

Purpose: To investigate diffraction gratings using DFFT
"""

#set up constants
alpha = np.pi/20 # 1/um
w = 200 #um
W = 10*w # 2000 um - padding is opaque
lamb = 500 #nm
focal_length = 1 #m (f)
screen_width = 10 #cm

# k = w*x/(lamb * f)

def q(u):#transmission function
  return np.sin(u*alpha)**2 # note then that u must be in units of um

# First we do the naive integration to check our work
from scipy.integrate import trapezoid
def integrand(u,x):
  return np.sqrt(q(u)) * np.exp(1j*2*np.pi*x*u/(lamb*1e-3 * focal_length*1e6))

u = np.array([w/2*(i/500) for i in range(-500,500)])

screen_pos = [i for i in range(-50000,50000)]

intensities = [np.abs(trapezoid(integrand(u,x),u))**2 for x in screen_pos ]

plt.plot(screen_pos,intensities)
plt.title("correct diffraction pattern")
plt.show()

N=1000 #number of sample points along diffraction grating
u_n = [ n*W/N - W/2  for n in range(N+1) ]
y = [np.sqrt(q(u_n[i])) if np.abs(u_n[i]) < w/2 else 0 for i in range(N)] #samples
# Set the samples to cover a large range - thus enabling large N, but set to 0 if |u| >= w/2. This allows us to make N as large as we want without altering the samples

from numpy.fft import rfft

c = rfft(y)
#unfortunately rfft will only compute for k in range(N) which mean that x is always positve. Luckily, we know that I is symmetric about zero
# thus we can simply reflect the coeficients across the y-axis

#intensity
m = len(c)
I = np.zeros(2*m,float)
for i in range(m):
  I[m + i] = abs(c[i])**2 * W**2 / N**2
  I[m - 1 - i] = abs(c[i])**2 * W**2 / N**2 # reflecting the coeficients accross the y-axis

x = np.array([lamb*1e-3 * focal_length*1e6 * k / W for k in range(-m,m) ])/1e4 # put in cm

#now we plot the intensities on the 1D screen
I *= 1e-12 # correct units
plt.plot(x,I)
plt.xlim(left=-5,right=5) # set the limits of the graph so that we only display what the screen sees
plt.xlabel("Position on screen (cm)")
plt.ylabel(r"Intensity $\left(\frac{kg}{s^3}\right)$")
plt.title("Diffraction Pattern intensies on 10 cm long screen")
plt.show()

# Now we create the density plot
# the intensities on the y-axis should be constant so we can just create a matrix by repeating the same row.

mat = np.array([I.tolist() for i in range(200)])
#print(mat)

plt.imshow(mat,cmap="grey",extent=[-5, 5, -1, 1]) # Use mat for the image and set extent for correct axis labels
plt.xlabel("Position on screen (cm)")
plt.ylabel("")
plt.yticks([])
plt.title("Diffraction Pattern Density Plot")
plt.show()

