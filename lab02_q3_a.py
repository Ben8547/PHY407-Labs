# -*- coding: utf-8 -*-
"""Lab02_Q3_a.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NJ026UUnr0NVdFU2IyvXlrXxN-hpceRH
"""

#Author: Ben Campbell
#Purpose: to find the voltage of an infinite wire by integrate with Simpson's method.

'''
DEFINE variables l and Q

DEFINE a function for the integrand

DEFINE a function to perform Simpson's rule integration (if number of intervals is not )

DEFINE a function for the voltage that intake r and z as arguments and returns the voltage at that point.

IMPORT bessel functions from scipy

COMPARE
'''

import numpy as np
from scipy import constants as c
import matplotlib.pyplot as plt
from scipy.special import kn # import modified bessel functions of the second kind

l = 1./1000. #m (1. mm)
Q = 1e-13 #C
eps = c.epsilon_0

def integrand(u,r,z):
    return Q*np.exp(-(np.tan(u))**2)/ ( 4*c.pi * eps * (np.cos(u))**2 * np.sqrt((z-l*np.tan(u))**2 + r**2) )

def integrate_Simpson(function, start, end, num_intervals):
  if type(num_intervals) != int:
    num_intervals = int(num_intervals)

  interval_width = (end - start) / num_intervals

  sum_even = 0.
  sum_odd = 0.

  if num_intervals % 2 != 0:
    effective_num_intervals = num_intervals - 1
  else:
    effective_num_intervals = num_intervals

  for i in range(1, effective_num_intervals, 2):
    sum_even += 2.*function(start + interval_width * (i+1))
    sum_odd += 4.*function(start + interval_width * i)

  if num_intervals % 2 != 0:
    #Do a trapezoidal area on the last segment
    last_area = interval_width*( function(end-interval_width) + function(end) )/2
    return interval_width/3 * (function(start) + function(end) + sum_even + sum_odd) + last_area
  else:
    return interval_width/3 * (function(start) + function(end) + sum_even + sum_odd)

#test
'''
test = lambda x: x**2
print(integrate_Simpson(test, 0, 1, 1e6)) #should be 1/3
'''
#end test

def voltage(r,z,num_intervals):
  num_intervals = int(num_intervals)
  if type(r) != list and type(r) != np.ndarray: # this allows us to pass both lists and scalars
    r = np.array([r])
  integrands = {"integrand_{0}".format(i): (lambda u, i=i: integrand(u, r[i], z)) for i in range(len(r))} # must use i=i to avoid late binding
  sol = np.array([integrate_Simpson(integrands["integrand_%i"%i], -c.pi/2., c.pi/2., num_intervals) for i in range(len(r))])
  return sol


#voltage for N=8
radii = np.linspace(.25/1000., 5./1000.,int(1e3))
v_1 = voltage(radii,0,8)


#Actual Voltage for z = 0
v_actual = lambda r: (Q/(4*c.pi*eps*l)) * np.exp(r**2 / (2*l**2)) * kn(0,r**2 / (2*l**2))

plt.plot(radii, v_1, label="Simpson's: N=8")
plt.plot(radii, v_actual(radii), label="Actual voltage for z=0", ls='--')
plt.legend()
plt.title("Voltage measured against radius, theoretical curve\nversus N=8 Simpson approximation")
plt.xlabel("Radius (m)")
plt.ylabel("Voltage (V)")
plt.show()

# compute the fractional error at each point

Fractional_error = np.abs((v_1 - v_actual(radii))/v_actual(radii))
plt.plot(radii, Fractional_error)
plt.xlabel("Radius (m)")
plt.ylabel("Fractional Error")
plt.title("Fractional error measured against radius (N=8)")
plt.show()

# Now repeat the above for larger N. Newman says that Simpson's method caps out at N ~ a few thousand so we try N=2000

v_2 = voltage(radii,0,2000)

Fractional_error = np.abs((v_2 - v_actual(radii))/v_actual(radii))
plt.scatter(radii, Fractional_error, marker = '.') #plt.plot was too messy
plt.xlabel("Radius (m)")
plt.ylabel("Fractional Error")
plt.title("Fractional error measured against radius (N=2000)")
plt.show()

# Notice that the error is on the order of magnetude 1e-15, only one order of magnetude away from the machine rounding error.
# This is pretty much as good as we can get.

#Let's see how low we can go for an error of 1e-6
v_2 = voltage(radii,0,200)
Fractional_error = np.abs((v_2 - v_actual(radii))/v_actual(radii))
plt.scatter(radii, Fractional_error, marker = '.') #plt.plot was too messy
plt.xlabel("Radius (m)")
plt.ylabel("Fractional Error")
plt.title("Fractional error measured against radius (N=200)")
plt.show()

v_2 = voltage(radii,0,50)
Fractional_error = np.abs((v_2 - v_actual(radii))/v_actual(radii))
plt.scatter(radii, Fractional_error, marker = '.') #plt.plot was too messy
plt.xlabel("Radius (m)")
plt.ylabel("Fractional Error")
plt.title("Fractional error measured against radius (N=50)")
plt.show()
#N=50 seems to be about the limit.

