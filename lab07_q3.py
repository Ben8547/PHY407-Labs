# -*- coding: utf-8 -*-
"""Lab07_Q3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W1cmWr2Ce93kwoRMmpiiKY00EnfP7-8p
"""

'''
Author: Ben Campbell
Purpose: To implement a variable step size B-S alogorithm and use it to integrate a set of ODEs representing a chemical oscilator
'''

#setup
import numpy as np
from numpy import empty,array,arange
from pylab import plot,show, vlines, title, ylabel, xlabel, legend

# integration functions

def BS_step(func, initial_condition: np.ndarray, time_range: tuple, delta: float = 1e-3, n_max = 8): # function adapted from Newmnn's example
  t0, tf = time_range
  H = tf-t0
  # Do one modified midpoint step to get things started
  n = 1 # number of approximations
  r1 = initial_condition + 0.5*H*func(t0, initial_condition)
  r2 = initial_condition + H*func(t0+0.5*H, r1)
  # The array R1 stores the first row of the
  # extrapolation table, which contains only the single
  # modified midpoint estimate of the solution at the
  # end of the interval
  R1 = empty(1,dtype=np.ndarray)
  R1[0] = 0.5*(r1 + r2 + 0.5*H*func(tf,r2)) # this is R_{1,1}

  # Now increase n until the required accuracy is reached
  error = 2*H*delta # at least one loop is completed
  while np.all(error > H*delta) and (n <= n_max):
      n += 1
      h = H/n
      # Modified midpoint method
      r1 = initial_condition + 0.5*h*func(t0,initial_condition)
      r2 = initial_condition + h*func(t0+0.5*h,r1)
      for i in range(n-1):
          r1 += h*func(t0+i*h,r2)
          r2 += h*func(t0+(i+0.5)*h, r1)

      # Calculate extrapolation estimates.  Arrays R1 and R2
      # hold the two most recent lines of the table
      R2 = np.copy(R1)
      R1 = empty(n,dtype=np.ndarray)
      R1[0] = 0.5*(r1 + r2 + 0.5*h*func(tf,r2))
      for m in range(1,n):
          epsilon = (R1[m-1]-R2[m-1])/((n/(n-1))**(2*m)-1)
          R1[m] = R1[m-1] + epsilon
      error = abs(epsilon)

  # Set r equal to the most accurate estimate we have before
  # moving on to the next big step
  r = R1[n-1]
  return r, error

def halving_time_step_BS(func, initial_condition, time_range, delta: float = 1e-3, n_max: int = 8, H_max = 1.):
  t0, tf = time_range
  H = min(tf-t0, H_max) # get the H interval width, if the entire interval is larger than H_max, set it to H_max - this prevent overflow error during the modified midpoint method
  values = [initial_condition] # stores integration points
  times = [t0] # stores time points
  tpoints = arange(t0,tf,H)
  machine_error = np.finfo(float).eps
  # call integration step an initial time
  for t in tpoints:
    r, error = BS_step(func, initial_condition, (t, t+H), delta, n_max) # get an initial approximation
    error = np.max(error) # error is in general an array so we just take the largest entry as the error
    if error > max(H*delta,10*machine_error):
      times1, values1 = halving_time_step_BS(func, initial_condition, (t, t+H/2), delta, n_max) # recurse on halved interval
      initial_condition = values1[-1]
      times.append(times1[-1])
      values.append(initial_condition)
      times2, values2 = halving_time_step_BS(func, initial_condition, (times1[-1], t+H), delta, n_max) # recurse on other half of interval
      initial_condition = values2[-1]
      times.append(times2[-1])
      values.append(initial_condition)

    else:
      values.append(r)
      times.append(t+H)
      initial_condition = r
  return times, values

#test
def test_ODE(t,y):
  return y

times, y_num = halving_time_step_BS(test_ODE, 1, (0,5),1e-10,8,1.)
vlines(times,0,y_num, ls=':',color='k')

#print(times)
#print(y_num)

plot(times,y_num, label="numerical")
plot(times,np.exp(times),label='actual',ls='-.')
legend()
title("test")
show()

# chemical equation ODE
def ODE(t,vec: np.ndarray, a, b): #implement the ODE
  x = vec[0]
  y = vec[1]
  dxdt = 1 - (b+1)*x + a*x**2 * y
  dydt = b*x - a*x**2 *y
  return np.array([dxdt,dydt],dtype=float)

# simulation parameters
a = 1
b = 3
x_0, y_0 = (0.,0.)
delta = 1e-10 # accuracy per unit time
t0 = 0
tf = 20

sim_ODE = lambda t,vec: ODE(t,vec,a,b)

# solve the ODE
delta = 1e-10
times, values = halving_time_step_BS(sim_ODE,np.array([x_0,y_0]),(0,20),delta, n_max=8,H_max=0.9)

#print(times)

# plot

plot(times,values,label=['[A]','[B]'])
vlines(times,0,[np.max(values[i]) for i in range(len(values))], ls=':',color='k')
legend()
title("test")
title("Belousov-Zhabotinsky Reaction")
ylabel("Concentration")
xlabel("Time")
show()

# Sanity check with RK4
def rk4(f, initial_conditions, t_final, dt): #integrates with RK4. initial conditions must be given with time first - ODE must take time as first argument
  # f should output an n-list of floats. Each entry of this list gives the derivative of the ith 1st order ODE.
  tpoints = np.arange(initial_conditions[0],t_final,dt)
  # we want this to generalize to a system of n ODEs
  n = len(initial_conditions) - 1 # subtract one because we don't want to count t_0
  xpoints = { "x_%i"%i : [initial_conditions[i+1]] for i in range(n)} # initialize the list of coordinates with the initial conditions
  # use a dictionary so that it is variable length
  for t_i in range(len(tpoints)-1):
    for i in range(n):
      current_conditions = [ xpoints["x_%i"%j][t_i] for j in range(n) ]   #take the last of each coordinate; use t_i index so that on loop t_i we only use the conditions from t_i-1 not a mix (index of -1 would cause a mix).
      k1 = dt*f(tpoints[t_i],*current_conditions)[i] # since f may be a function of arbitray many coordinates we unpack the list
      k2 = dt*f(tpoints[t_i]+0.5*dt,*[current_conditions[j] + 0.5*k1 for j in range(n)])[i]
      k3 = dt*f(tpoints[t_i]+0.5*dt,*[current_conditions[j] + 0.5*k2 for j in range(n)])[i]
      k4 = dt*f(tpoints[t_i]+dt,*[current_conditions[j] + k3 for j in range(n)])[i]
      xpoints["x_%i"%i].append(current_conditions[i])
      xpoints["x_%i"%i][-1] += (k1+2*k2+2*k3+k4)/6 # i have reservation about the efficiency of all this list generation and unpacking but I can't think of a better way to do this in complete generality
  return tpoints, [xpoints["x_%i"%i] for i in range(n)] # times and list of lists

def rk_sim_ODE(t,x,y: np.ndarray): #implement the ODE
  dxdt = 1 - (b+1)*x + a*x**2 * y
  dydt = b*x - a*x**2 *y
  return np.array([dxdt,dydt],dtype=float)

rk_times, rk_values = rk4(rk_sim_ODE,[0.,0.,0.],20,0.0001)


plot(rk_times,rk_values[0],label="[A]")
plot(rk_times,rk_values[1],label='[B]')
title("Belousov-Zhabotinsky Reaction")
ylabel("Concentration")
xlabel("Time")
legend()
show()