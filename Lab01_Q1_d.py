# -*- coding: utf-8 -*-
"""Lab01_Q1_d

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B6y7_JBZ1CzrSiApC2SBj61SFVgEtyO-
"""

#Purpose: To show the precession of Murcury's orbit

# IMPORT numpy, matplotlib.pyplot, Visual
import numpy as np
import matplotlib.pyplot as plt

#Allow the user to INPUT start and end times as well as r_0 (assume \dot r = 0), \theta and \dot\theta.
'''try:
    r_0 = float(input("initial radius (m; recommended value is 1): "))
    theta_0 = float(input("initial angle (radians): "))
    dot_theta_0 = float(input("initial angular velocity (radians/second; recommended value is 10): "))
except:
    print("Please input a valid floating point number.")
    raise ValueError'''

#For Murcury the inital conditions are
r_0 = np.sqrt(.47**2 + 0.**2) #AU
dot_r_0 = 0 # AU/year
theta_0 = 0 #radians
dot_theta_0 = np.sqrt(8.17**2 + 0.**2)/r_0 # radians / year; orbit is locally a circle so this conversion hopefully works

beg = 0 #year
length_murcury_year = 0.24109589041 # earth years

# DEFINE the values of various parameters: m, M_s, G, \alpha in appropriate units.

m = 1.65157869e-7 #~mass of murcury in units of (earth mass + sun mass + moon mass)
M_s = 0.99999696055 #~mass of sun in units of (earth mass + sun mass + moon mass)
G = 39.478 # Gravitational Constant in units of au^3 (earth mass + sun mass + moon mass)^{-1} yr^{-2}
alpha = 0.01 #AU**2

# Define L (angular momentum) = mr^2\dot\theta.

L = m * r_0**2 * dot_theta_0

#DEFINE functions for the advancement of each r, \theta, \dot\theta and \dot r. These functions should intake r_i (resp. \theta_i, \dot r_i), \dot r_i (resp. ...) and \Delta t, outputting the advancement of the value in the sequence.

def r_advance(r, dot_r ,dt):
    return r + dot_r*dt
def dot_r_advance(dot_r,r,dot_theta, dt):
    return dot_r + (r * dot_theta**2)*dt - (G*M_s/(r**2))*(1+alpha/r**2)*dt
def theta_advance(theta, dot_theta, dt):
    return theta + dot_theta*dt
def dot_theta_advance(dot_theta, r, dot_r, dt):
    return dot_theta - (2*dot_r*dot_theta/r)*dt

#Now we will do the same process as in part 1C excpet will will define a dctionary to hold the trajectories for each murcury year so that we can see the change in the orit more clearly

num_murcury_years = 10
position_years_dictionary = { 'position_year_%i'%i: [] for i in range(num_murcury_years)}
angle_years_dictionary = {'angle_year_%i'%j: [] for j in range(num_murcury_years)}
angular_velocity_years_dictionary = {'ang_vel_year_%i'%j: [] for j in range(num_murcury_years)}
radial_velocity_years_dictionary = {'rad_vel_year_%i'%j: [] for j in range(num_murcury_years)}

#Set initial conditions

position_years_dictionary['position_year_0'] = [r_0]
angle_years_dictionary['angle_year_0'] = [theta_0]
angular_velocity_years_dictionary['ang_vel_year_0'] = [dot_theta_0]
radial_velocity_years_dictionary['rad_vel_year_0'] = [dot_r_0]

Angular_Momentum = [L]
aphelion_x, aphelion_y = [], []

for i in range(num_murcury_years):

  # Set initial conditions (start where the last year left off):
  if i != 0:
    position_years_dictionary['position_year_%i'%i] = [position_years_dictionary['position_year_%i'%(i-1)][-1]]
    angle_years_dictionary['angle_year_%i'%i] = [angle_years_dictionary['angle_year_%i'%(i-1)][-1]]
    angular_velocity_years_dictionary['ang_vel_year_%i'%i] = [angular_velocity_years_dictionary['ang_vel_year_%i'%(i-1)][-1]]
    radial_velocity_years_dictionary['rad_vel_year_%i'%i] = [radial_velocity_years_dictionary['rad_vel_year_%i'%(i-1)][-1]]
    beg += length_murcury_year

  #ITERATE through the array of time points.

  position = position_years_dictionary['position_year_%i'%i]
  angle = angle_years_dictionary['angle_year_%i'%i]
  angular_velocity = angular_velocity_years_dictionary['ang_vel_year_%i'%i]
  radial_velocity = radial_velocity_years_dictionary['rad_vel_year_%i'%i]

  #CREATE and array of N evenly spaced time points. DEFINE \Delta t (\Delta t = 0.0001 year) as the spacing. Make N so that N\Delta 1 = t year.
  dt = 0.0001
  times = np.arange(start=beg, stop=beg+length_murcury_year, step = dt)

  for t in range(len(times)):
    #CALL the advancement function for \dot r. APPEND this value to the velocity list.
      radial_velocity.append(dot_r_advance(radial_velocity[t],position[t],angular_velocity[t],dt))
    #CALL the advancement function for r and use the new \dot r. APPEND this value to the position list.
      position.append(r_advance(position[t],radial_velocity[t+1],dt))
    #CALL the advancement function for \dot\theta. APPEND this value to the angular velocity list.
      angular_velocity.append(dot_theta_advance(angular_velocity[t],position[t],radial_velocity[t],dt))
    #CALL the advancement function for \theta and use the new \dot\theta. APPEND this value to the angle list.
      angle.append(theta_advance(angle[t],angular_velocity[t+1],dt))
    #CALCULATE angular momentum for the new time point. APPEND it to the appropriate list.
      Angular_Momentum.append(m* (position[t+1]**2) *angular_velocity[t] )

  #Reconvert to cartesian coordinates.
  position = np.array(position)
  angle = np.array(angle)
  x = np.multiply(position,np.cos(angle))
  y = np.multiply(position,np.sin(angle))
  # Add to plot
  plt.plot(x,y,ls='-',label="path of Mercury in Murcury year %i"%(i+1))

  # To plot aphelion for each year, we find the furthest value of "position" and plot the point. Use np.argmax to extract index of max radius
  aphelion_index = np.argmax(position)
  aphelion_x.append(x[aphelion_index])
  aphelion_y.append(y[aphelion_index])


#END OF LOOP

#Find RMS deviation of angular momentum from mean
Angular_Momentum = np.array(Angular_Momentum)
L_rms = L_rms = np.sqrt(np.average(np.power(np.subtract(Angular_Momentum,Angular_Momentum),2))) # square root of the average of the squares of the deviations from the initial angular momentum

print("RMS Deviation of angular momentum: {0:.5e}".format(L_rms)) # check if constant

#Finalize PLOT
plt.plot(aphelion_x,aphelion_y,'o',label="aphelions",ls='none')
plt.title("The orbit of Mercury about the Sun")
plt.xlabel("AU")
plt.grid()
plt.ylabel("AU")
plt.xlim(-.6,.6)
plt.ylim(-.6,.6)
plt.plot(0,0,'o',label="sun",color = 'orange')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)
plt.show()

