# -*- coding: utf-8 -*-
"""Lab10_Q2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FmVpIa2rD3w4lKckg22fkddv4ZjTXUo_

Author: Benjamin Campbell

Purpose:
"""

!pip install warp-lang # if TA has warp then this line may be removed (or may need to intall directly in consol)

#setup
import numpy as np
import matplotlib.pyplot as plt
import warp as wp

# tests - not related to lab

X = np.random.rand(10000)
h=plt.hist(-np.log(X),bins=20,rwidth=0.9)
#plt.plot(10000*np.e**np.sort(X))
#print(h)
x = np.linspace(0,10,1000)
plt.plot(x,h[0][0]*np.e**(-x))
plt.show()

# end of tests

# Photon Scattering Functions, curtosy of N.G.

def get_tau_step():
  """ Calculate how far a photon travels before it gets scattered.
  OUT: optical depth traveled """
  delta_tau =-np.log(np.random.random()) # exponential distrobution of some sort - gives values from 0 to \infty; highest probability at 0
  # follows the PDF p(x) = a e^{-x} for x < 0
  return delta_tau # this is always positive

def emit_photon(tau_max):
  """ Emit a photon from the stellar core.
  IN: tau_max is max optical depth
  OUT:
  tau: optical depth at which the photon is created
  mu: directional cosine of the photon emitted """
  tau = tau_max
  delta_tau = get_tau_step()
  mu = np.random.random()
  return tau - delta_tau*mu, mu # take delta_tau*mu because delta_tau is total distance moved, so movement verically is given by multiplication by cos
  #tau can only decrease

def scatter_photon(tau):
  """ Scatter a photon.
  IN: tau, optical depth of the atmosphere
  OUT:
  tau: new optical depth
  mu: directional cosine of the photon scattered """
  delta_tau = get_tau_step()
  mu = 2*np.random.random()-1 # sample mu uniformly from-1 to 1
  return tau - delta_tau*mu, mu # tau may increase or decrease

# part A: write a function that generates a random photon in the atmosphere give the maximum depth of the atmosphere
# The function follows the particle through the atmosphere to determine the the final angle

def gen_photons(tau_max, N=1):
  '''
  tau_max = depth of the atmosphere
  N = number of photons to simulate
  '''
  emit_photons = [emit_photon(tau_max) for i in range(N)] # list of N photons, list contains tuples: 1st entry: depth of the photon (tau); second entry: cosine of the angle (mu)
  times_scattered = []
  for i in range(N):
    tau, mu = emit_photons[i]
    count = 0
    while tau > 0: # keep scattering the photon until ou reach the surface
      tau, mu = scatter_photon(tau)
      if tau > tau_max:
        tau, mu = emit_photon(tau_max) # emit new photon if the photon scatters into the core
        # if we don't do this the program is even less likely not to terminate - I don't think it is guarenteed to terminate as is
      count += 1
    emit_photons[i] = (tau, mu) # final depth and cosine of angle
    times_scattered.append(count) # number of scattering events
  return emit_photons

'''# part A: write a function that generates a random photon in the atmosphere give the maximum depth of the atmosphere
# The function follows the particle through the atmosphere to determine the the final angle


def gen_photons(tau_max, N=1): # we can make this a warp kernel and simulate each photon at once - should save time
  """
  tau_max = depth of the atmosphere
  N = number of photons to simulate
  """
  vecN = wp.vec(N,wp.float64) # define length N warp vector data type

  @wp.kernel
  def sim_photon(tau: vecN, mu: vecN,times_scattered: wp.Array, tau_max: wp.float64):
    """tau = depth of the atmosphere
    mu = cosine of the angle"""
    i = wp.tid()
    depth = tau[i]
    cos_angle = mu[i]
    count = 0
    while depth > 0: # keep scattering the photon until ou reach the surface
      depth, cos_angle = scatter_photon(tau)
      if depth > tau_max:
        depth, cos_angle = emit_photon(tau_max) # emit new photon if the photon scatters into the core
      count += 1
    tau[i] = depth # final depth and cosine of angle
    mu[i] = cos_angle
    times_scattered[i] = count # number of scattering events

  # end of warp kernel

  emit_photons_tau = vecN([emit_photon(tau_max)[0] for i in range(N)]) # vector of N photons, list contains depth of the photon (tau)
  emit_photons_mu = vecN([emit_photon(tau_max)[1] for i in range(N)]) # list contains cosine of angle (mu)
  times_scattered = wp.zeros(N) # number of times each photon is scattered; initialze

  wp.launch(sim_photon,N,[emit_photons_tau,emit_photons_mu,times_scattered,tau_max])

  return emit_photons_tau, emit_photons_mu, times_scattered
''' # I wanted to use warp to speed this up, but it was clunky and the provided functions are not designed for it. Please ignore this block

# part b

N = round(1e5)
tau_max = 10

final_data = gen_photons(tau_max, N)
print(final_data)

mu = [ final_data[i][1] for i in range(N) ]
tau = [ final_data[i][0] for i in range(N)]

# plot a histogram of the cosine of the angle
num_bins = 20
h = plt.hist(mu, bins=num_bins,rwidth=0.9)
plt.xlabel(r'Cosine of the angle ($\mu$)')
plt.ylabel('Number of photons (N)')
plt.title(r'Histogram of the cosine of the angle ($\mu$) when $\tau_{\max} = 10$')
plt.show()

#organize histogram data
bin_edges = h[1]
bin_centers = np.array([ (bin_edges[i]+bin_edges[i+1])/2 for i in range(num_bins) ])
bin_size = h[0]

# we know that I \propto N(\mu) / \mu. But this quanity is the slope of the line when we plot N against \mu. Thus we regress

from scipy.optimize import curve_fit

def fit(x,a,b):
  return a*x+b

popt, pcov = curve_fit(fit, bin_centers, bin_size/bin_size[-1]/bin_centers)

#plot

plt.plot(bin_centers,bin_size/bin_size[-1]/bin_centers,label='simulated data',ls='none',marker='.') # raw data
plt.plot(bin_centers, fit(bin_centers, *popt),label='fit') # linear fit
plt.plot(bin_centers, (0.4+0.6*bin_centers),label = 'theoretical curve') # theoretical curve

plt.legend()
plt.xlabel(r'Cosine of the angle ($\mu$)')
plt.ylabel(r'Normalized intensity $\left(\frac{N(\mu)}{N(\mu_N)\mu}\right)$')
plt.title("Simulated and Theoretical dependence of\nthe normalized intensity as a function of\nscattering angle ($\\tau_{\\max} =$"+"%.4f)"%(tau_max))


plt.grid()

plt.show()

print(popt)
#print(0.6*bin_size[0], 0.4*bin_size[0])

def gen_graph(tau_max,N): # define a function to do all of the steps at once
  final_data = gen_photons(tau_max, N)
  mu = [ final_data[i][1] for i in range(N) ]
  tau = [ final_data[i][0] for i in range(N)]
  h = np.histogram(mu, bins=num_bins)
  bin_edges = h[1]
  bin_centers = np.array([ (bin_edges[i]+bin_edges[i+1])/2 for i in range(num_bins) ])
  bin_size = h[0]
  popt, pcov = curve_fit(fit, bin_centers, bin_size/bin_size[-1]/bin_centers)
  plt.plot(bin_centers,bin_size/bin_size[-1]/bin_centers,label='simulated data',ls='none',marker='.') # raw data
  plt.plot(bin_centers, fit(bin_centers, *popt),label='fit') # linear fit
  plt.plot(bin_centers, (0.4+0.6*bin_centers),label = 'theoretical curve') # theoretical curve
  plt.legend()
  plt.xlabel(r'Cosine of the angle ($\mu$)')
  plt.ylabel(r'Normalized intensity $\left(\frac{N(\mu)}{N(\mu_N)\mu}\right)$')
  plt.title("Simulated and Theoretical dependence of\nthe normalized intensity as a function of\nscattering angle ($\\tau_{\\max} =$"+"%.4f)"%(tau_max))

  plt.grid()

  plt.show()
  return

gen_graph(10,N)

gen_graph(1.,N)

gen_graph(0.1,N)

gen_graph(0.01,N)

gen_graph(0.001,N)

gen_graph(0.0001,N)

gen_graph(100,N) # this takes an absurd amount of time to run - only run if required

